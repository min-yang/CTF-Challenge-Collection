# Pwn挑战合集

- [CGfsb](CGfsb)：格式化字符串漏洞任意写
- [cgpwn2](cgpwn2)：缓冲区溢出修改返回地址
- [dice_game](dice_game)：缓冲区溢出修改随机数种子
- [forgot](forgot)：缓冲区溢出修改稍后会调用的函数指针
- [guess_num](guess_num)：缓冲区溢出修改随机数种子
- [int_overflow](int_overflow)：首先利用整数溢出绕过检查，然后利用缓冲区溢出修改返回地址
- [level0](level0)：缓冲区溢出修改返回地址
- [level2](level2)：缓冲区溢出控制执行流程
- [level3](level3)：利用缓冲区溢出构造ROP泄露libc基址，然后跳转到system函数
- [Mary_Morton](Mary_Morton)：首先利用格式化字符串漏洞泄漏canary的值，然后利用缓冲区溢出漏洞控制执行流程
- [new-easypwn](new-easypwn)：无法成功利用，有待进一步研究
- [pwn-100](pwn-100)：存在缓冲区溢出，但是不知道libc的地址，需要使用DynELF找出libc的地址，然后控制执行流程
- [stack2](stack2)：代码逻辑漏洞，可以往某段内存区域写入任意数据，借此直接修改返回地址控制执行流程
- [string](string)：利用格式化字符串漏洞任意写绕过检查，然后就可以传入一段shellcode拿到shell权限
- [warmup](warmup)：缓冲区溢出盲打，需要爆破出返回地址的位置然后控制执行流程
- [pwn1](pwn1)：缓冲区溢出利用，但是需要先泄漏canary的值，以及libc的基地址，然后构造攻击ROP，由于服务器上没有/bin/sh，因此需要one_gadget
- [反应釜开关控制](反应釜开关控制)：缓冲区溢出直接控制流程
- [pwn-200](pwn-200)：缓冲区溢出，先构造ROP泄漏libc函数的地址，然后借助LibSearcher推测可能使用的libc，借此算出基址，然后构造ROP运行shell
- [实时数据监测](实时数据监测)：利用格式化字符串漏洞进行任意写，由于要写的值比较大，因此构造起来稍微复杂一点
- [welpwn](welpwn)：缓冲区溢出利用，需要使用LibcSearcher寻找匹配的libc库，尝试使用DynELF报错，原因未知
- [time_formatter](time_formatter)：UAF利用，有待进一步学习，尤其是要清楚哪些函数会分配堆
- [Recho](Recho)：缓冲区溢出利用，但是只有断开后函数才会返回，因此无法getshell且无法泄漏libc的基址，要构造一次性的ROP，借助alarm中的syscall完成
- [greeting-150](greeting-150)：格式化字符串漏洞，构造比较复杂，劫持strlen的GOT地址，此外还需要修改fini_array的值避免程序结束
- [note-service2](note-service2)：堆分配机制考察，此外还考察指令构造能力，每个chunk只能写7个字节，在这个限制下构造shellcode
- [secret_file](secret_file)：缓冲区溢出利用，但解决问题的主要靠的是逆向能力
- [supermarket](supermarket)：堆利用机制考察，目前的方案仅适用于Tcache机制之前的环境，Tcache环境下如何攻击还有待研究
- [4-ReeHY-main-100](4-ReeHY-main-100)：利用堆的unlink机制改写任意内存，目标程序没有将free的指针置0，给了攻击者机会
- [pwnstack](pwnstack)：非常基本的栈溢出题，但是如何在libc2.35版本下成功利用有待研究
- [babyfengshui](babyfengshui)：堆溢出利用，但是有个检查机制需要绕过，存在Tcache和不存在Tcache时需要使用不同的方法，两种方法目前都开发出来了
- [Noleak](Noleak)：堆溢出利用，但是没有地方泄露数据，所以要精心构造在不知道堆栈和libc基址的情况下执行shellcode的方法，目前仅有libc2.23的方法，如何在2.35下成功攻击有待研究
- [1000levevls](1000levevls)：栈溢出利用，但是开启了PIE，且无法泄露地址，因此需要想办法通过运算在栈中构造出one_gadget地址，此外，偏移量需要填充vsyscall指令，因为vsyscall指令地址是不会变化的，即使开了PIE，如果不支持vsyscall，该方法无法成功
- [hacknote](hacknote)：UAF利用，注意print note的逻辑，函数指针的值会作为函数的参数，前4个字节不可控，后四个字节补`||sh`即可成功利用
- [format2](format2)：栈溢出问题，但是只能覆盖ebp的值，无法覆盖返回地址，通过将ebp改为我们控制区域的首地址，那么下一次函数返回地址就是首地址+4处的值
- [dubblesort](dubblesort)：栈溢出利用，首先需要读栈中残留的数据泄露libc，其次要想办法绕过canary防护
- [echo_back](echo_back)：格式化字符串漏洞，但是只能写7个字节，需要精心构造攻击方法，需要了解linux内核机制，这里是通过改写stdin结构体来完成攻击
- [EasyPwn](EasyPwn): 格式化字符串漏洞，但是涉及snprintf函数format参数的动态覆盖，原理尚不清楚，需要进一步研究
- [repeater](repeater)：栈溢出利用，但溢出范围刚好覆盖返回地址，因此需要提前布局shellcode
- [RCalc](RCalc)：利用堆溢出绕过作者自己实现的canary检测
- [HMI流水灯运行](HMI流水灯运行)：栈溢出利用，但是程序只给了很短的时间让你进行栈溢出，调试起来比较麻烦，这里通过修改二进制程序，使得等待时间缩短到六分之一
- [easyfmt](easyfmt)：格式化字符串漏洞，构造任意地址读，任意地址写的payload，借此拿下shell
- [250](250)：栈溢出利用，但是这个情况比较特殊，直接把libc链接到二进制程序中，且去除了system函数，因此需要通过int 0x80或者其它方法来获得shell
- [house_of_grey](house_of_grey)：栈溢出利用，但是这个保护全开，开启了新进程，手动设置了内存布局，且设置了seccomp，不能拿到shell，如何绕过各种机制拿到flag涉及的知识面较广
