# 题目描述

I heard that some common block cipher modes have lots of footguns - using none (ECB) results in the legendary [ECB Penguin](https://words.filippo.io/the-ecb-penguin/), while others are vulnerable to [bit flipping](https://en.wikipedia.org/wiki/Bit-flipping_attack) and [padding](https://en.wikipedia.org/wiki/Padding_oracle_attack) attacks, so I made my own that would never fall to such a technique.

# 解决方案

根据加密脚本，每256个字节一组，但是我们不需要传输256个以上的字节，因此不用考虑，256字节又被分成16个组，每组16个字节，加密的输入不是原始输入，会按照指定规则打乱，每16个字节的偏移i会被映射到第j个块，可以本地调试观察输入输出来理解这个转换，下面给出一个例子：

```python
PERMUTATION = [11, 10, 4, 9, 12, 13, 7, 14, 8, 15, 5, 0, 3, 1, 2, 6]
inp = '20007b2274797065223a20226563686f222c20226d7367223a20226161616161227d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
data = '2261000000000000000000000000000020220000000000000000000000000000746d00000000000000000000000000003a20000000000000000000000000000065610000000000000000000000000000636100000000000000000000000000006522000000000000000000000000000068610000000000000000000000000000223a00000000000000000000000000006f610000000000000000000000000000797300000000000000000000000000002022220000000000000000000000000022220000000000000000000000000000002c7d000000000000000000000000007b20000000000000000000000000000070670000000000000000000000000000'
```

其中inp为原始输入，data为输出，都通过hex形式表示，PERMUTATION为映射关系，先将输入分为16个一组，如下：

| Offset |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |
| ---    | ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---|
|    0   | 20 | 00 | 7b | 22 | 74 | 79 | 70 | 65 | 22 | 3a | 20 | 22 | 65 | 63 | 68 | 6f | 
|    1   | 22 | 2c | 20 | 22 | 6d | 73 | 67 | 22 | 3a | 20 | 22 | 61 | 61 | 61 | 61 | 61 | 
|    2   | 22 | 7d | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 
|    3   | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 
|    4   | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 
|    5   | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 
|    6   | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 
|    7   | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 
|    8   | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 
|    9   | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 
|   10   | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 
|   11   | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 
|   12   | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 
|   13   | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 
|   14   | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 
|   15   | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 00 | 

映射关系的第一项的值为11，即输入各组的第12个字节组成输出的前16个字节，所以输出的前16个字节的hex为：`22610000000000000000000000000000`，映射关系的第二项的值为10，对应的16个输出字节的hex为：`20220000...`，以此类推，得到打乱后的输出，然后经过AES-ECB加密后展现给客户端。

这里的解决思路是，先尝试修改16个组的字节，看看哪个组修改后会改变echo四个字符的值（只要将echo改成flag即可拿到flag），但是修改加密后的字符，解密后原始输入那一列的值都有可能会修改，可能导致解析错误，echo在输入中的偏移是12～15（从0开始计算），如下表所示：

| Offset |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |
| ------ | ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---|
|    0   |    |    |  { |  " |  t |  y |  p |  e |  " |  : |    |  " |  e |  c |  h |  o | 
|    1   |  " |  , |    |  " |  m |  s |  g |  " |  : |    |  " |  a |  a |  a |  a |  a | 
|    2   |  " |  } |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 
|    3   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 
|    4   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 
|    5   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 
|    6   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 
|    7   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 
|    8   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 
|    9   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 
|   10   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 
|   11   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 
|   12   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 
|   13   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 
|   14   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 
|   15   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 

因为AES-ECB加密的特性，16字节一组的输入对应16字节的输出，一共有16组输出，由于PERMUTATION的存在，第一组输出可能对应上表任意一列的输入，由于PERMUTATION是每次运行时随机生成的，因此我们需要遍历16次才知道echo四个字符分别对应哪4组输出；此外，加密生成的每一组，16个字节中的每个字节和对应输入列中的所有字符都是有关联的，举个例子，根据PERMUTATION，我们知道第1组输出对应11列的输入，所以我们修改第1组的第一个字节后，解密后对应上表的11列的值会变化，其中`"`被修改会导致json解析失败，服务器因此会返回Invalid command。

这些符号`{`、`}`、`"`、`,`是不能被修改的，修改后会导致json解析失败，message部分是我们能控制的，服务器收到message后，会将加密后的数据发送给我们，上表对应的message是aaaaa，但如果我们仅发送一个字符的message，则上表12列的a将变成敏感字符`"`，13列的"a"将变成敏感字符`}`，这时如果我们还想修改e和c两个字符，就会导致json解析失败，服务就只会返回Invalid command；因此我们送的message至少要有5个字符，此外不能超过15个字符。

发送5个字符后，我们拿到对应的加密输出，然后分成16一组，我们先找出哪4组对应echo四个字符，然后每一组16字节，每个字节256个值，遍历找到哪个字节修改为哪个值可以得到我们想要的值。具体参考脚本[solve.py](solution/solve.py)，以下是运行脚本调试本地程序的一次输出：

```
block offset: 5, hit 0: '�cho'
flag hit: 'fcho'
block offset: 0, hit 1: 'f�ho'
flag hit: 'flho'
block offset: 14, hit 2: 'fl�o'
flag hit: 'flao'
block offset: 2, hit 3: 'fla{'
flag: 'flag{yangmin}\n\n\n', if right input any character, if not, input nothing?1
```

可以看到，程序遍历发现了第5组对应e字符，并遍历找到使e变为f的位置及值，第0组对应c字符，以此类推，最后成功拿到flag，把本地程序换成远端即可拿到服务器上的flag，为irisctf{bad_at_diffusion_mode}。

为了加强理解，下面看个遍历找到一个加密值使e变为f时，这个加密值解密后对应的字符列表，如下表所示：

| Offset |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |
| ------ | ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---| ---|
|    0   |    |    |  { |  " |  t |  y |  p |  e |  " |  : |    |  " |  f |  c |  h |  o | 
|    1   |  " |  , |    |  " |  m |  s |  g |  " |  : |    |  " |  a |  t |  a |  a |  a | 
|    2   |  " |  } |    |    |    |    |    |    |    |    |    |    |  q |    |    |    | 
|    3   |    |    |    |    |    |    |    |    |    |    |    |    |  � |    |    |    | 
|    4   | |  |  |  |  |  |  |  |  |  |  |                           |  � |    |    |    | 
|    5   | |  |  |  |  |  |  |  |  |  |  |                           |\x0b|    |    |    | 
|    6   | |  |  |  |  |  |  |  |  |  |  |                           | � |  |  |  | 
|    7   | |  |  |  |  |  |  |  |  |  |  |                           | � |  |  |  | 
|    8   | |  |  |  |  |  |  |  |  |  |  |                           | � |  |  |  | 
|    9   | |  |  |  |  |  |  |  |  |  |  |                           |  |  |  |  | 
|   10   | |  |  |  |  |  |  |  |  |  |  |                           |  |  |  |  | 
|   11   | |  |  |  |  |  |  |  |  |  |  |                           | � |  |  |  | 
|   12   | |  |  |  |  |  |  |  |  |  |  |                           |  |  |  |  | 
|   13   | |  |  |  |  |  |  |  |  |  |  |                           | � |  |  |  | 
|   14   | |  |  |  |  |  |  |  |  |  |  |                           | F |  |  |  | 
|   15   | |  |  |  |  |  |  |  |  |  |  |                           | U |  |  |  |

可以看到，只有12列的值被修改，msg专用字符被修改不会有影响，此外，12列其它行不在json的解析范围内，修改了不影响解析，13列、14列和15列同理。