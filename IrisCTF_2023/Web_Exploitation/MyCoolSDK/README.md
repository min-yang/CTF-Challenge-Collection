# 题目描述

I've written a program that let's you encrypt and decrypt strings, but it uses a proprietary closed-source SDK through GitHub Actions. Of course you can fork it and only the magical GitHub black box will be able to see it. So there's no way you could dump the entire SDK... right?

Note: this challenge uses a non-standard flag format, irisCTF{}.

Also after solving, please delete your repository if you fork and make any changes to it so others can't cheat off of your repo.

Hint: this is not a rev challenge. No need to break IDA out for this one.

https://github.com/IrisSec/MyCoolEncryptor/

# 解决方案

这个题考察的是对github workflow的了解程度，我们的目的是获取coolsdk.tar.gz文件，但是这个文件只有经过服务器的验证后才能下载，分析源码，主要部分如下：

```js
function hasTokenNotExpired(tokenObj) {    
    if (tokenObj.status == "EXPIRED" || (Date.now() / 1000) - tokenObj.timeCreated > 120) {
        tokenObj.status = "EXPIRED";
        return false;
    }
    return true;
}
```

要求在120秒内完成整个过程。

```js
    let workflowContents = Buffer.from(fileInfo.data.content, "base64");
    let workflowHash = SHA256(workflowContents.toString()).toString();

    const MATCH_HASH = "8951a3d29206cf24600379fba7efeb7d8fc9181353a958f710a32eb786ae8654";
    if (workflowHash != MATCH_HASH) {
        console.log(`expected ${MATCH_HASH}, found ${workflowHash} hash for workflow!`);
        return undefined;
    }
```

workflow不能修改，所以我们无法通过修改workflow来渗出数据。

此外，workflow的日志不会输出MCSDK_TOKEN，所以我们无法手动构造请求获得目标文件。

```js
    // scan for server id string
    let idenStr = undefined;
    const target = "ServerID-";
    for (let i = startPos; i < logLines.length; i++) {
        if (logLines[i].includes(target) && !logLines[i].includes("echo")) {
            let idx = logLines[i].indexOf(target);
            let len = target.length;
            
            idenStr = logLines[i].substring(idx + len);
            break;
        }
        if (logLines[i].includes("##[debug]")) {
            return undefined;
        }
    }
```

workflow的日志必须包含正确的idenStr，如果不是这段验证，我们可以开个workflow，记录其runid，然后请求一个MCSDK_TOKEN，将这个MCSDK_TOKEN绑定到这个run_id和对应的库，然后就可以直接拿到目标文件了。

绕过的关键在于以下代码：

```js
    let jobLogInfo = await octo.request("GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs", {
        owner: owner,
        repo: repo,
        job_id: runJobInfo.data.jobs[0].id
    });
```

调用这个接口就会发现，log信息中包含库名，而且idenStr是可以直接从服务器上请求得到的，因此我们可以在拿到idenStr后将库名改为ServerID-idenStr即可绕过验证。

具体流程如下：

首先开个workflow，然后立马取消，记录其runid，然后请求/gettoken获得token；

然后请求/getiden，参数包含token、正常的库名、runid，请求后会得到一个idenStr；

然后我们将库名改为ServerID-idenStr，把之前runid对应的workflow重新跑一遍，GITHUB上对应的按钮为`Re-run all jobs`；

workflow的job会失败，但是不重要，重要的是日志中包含idenStr，然后我们请求/checkiden，请求参数带上token即可，顺利的话会返回OK，如果返回错误，则从头试下；

最后请求/getsdk，请求参数也是只有token，然后就可以顺利获得目标文件。

目标文件包含coolsdk文件夹，和库中的文件结合起来可以编译出目标程序，此外，目标文件中包含一个readme.txt，内容如下：

```
the cool sdk
------------
encrypt all your data with this cool sdk

(c) cool guy 2023


test decryption with:
ECDDD6B8B742A2015E9DBE50C20BE8094BF3084033325A0DCFA81896CDF5826C7EA68F320FC75DA3F776
69420
```

ECDDD6B8B742A2015E9DBE50C20BE8094BF3084033325A0DCFA81896CDF5826C7EA68F320FC75DA3F776为密文，69420为key，直接使用编译好的程序解密即可拿到flag。

```
irisCTF{my_sdk_wasnt_so_private_after_all}
```

参考链接：

- https://www.youtube.com/watch?v=1qzqOOLTZsg