# 题目描述

I'll let you seek around my file as far as you want, but you can't go anywhere since it's /dev/null.

To figure out where things are, you can use the gdb debugger. I recommend using a Docker instance, such as with the Dockerfile provided, to ensure you have an environment that matches the remote server you are attacking.

**Hint!** You can find the location of functions in the Global Offset Table by using their name followed by @got.plt - for example, `print &'fwrite@got.plt'`.

# 解决方案

由于程序开启了PIE保护，运行时所有地址都是动态变化的，因此我们需要通过win函数算出基地址，通过`objdump -d ./file/chal`可以看到win函数的偏移地址，由此可以在运行时算出基地址。

然后就是修改_IO_write_ptr的地址，我也不知道要改成啥才行，就一个一个got函数去试，最后试出当_IO_write_ptr的地址指向exit函数时，会运行win函数，显示flag，为irisctf{not_quite_fseek}，具体参考脚本[solve.py](solution/solve.py)。

***

更新：

关键代码如下：

```c
fwrite(&super_special, sizeof(void*), 1, null);
```

这句代码是把win函数的地址写入null指向的地址，即_IO_write_ptr，之所以将_IO_write_ptr的地址修改为exit函数的GOT地址，是因为这句代码执行完之后main函数会执行exit函数，且exit函数是第一次执行，第一次执行会查got表然后跳转，结果就跳到了win函数，然后拿到flag。